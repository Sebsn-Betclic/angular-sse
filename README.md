# DemoSse

<a alt="Nx logo" href="https://nx.dev" target="_blank" rel="noreferrer"><img src="https://raw.githubusercontent.com/nrwl/nx/master/images/nx-logo.png" width="45"></a>

✨ **This workspace has been generated by [Nx, Smart Monorepos · Fast CI.](https://nx.dev)** ✨

## Compatibilité 

https://caniuse.com/eventsource

Server Sent Event est une norme et elle n’est pas toute jeune puisque Opera l’a implémenté de façon expérimentale en 2006, le W3C l’a validé en 2013. Du fait de son âge, elle est pleinement supportée par la plupart des navigateurs.

server send event messageContrairement aux WebSocket, le SSE fonctionne sur le protocole HTTP et la communication est unilatérale, on ne peut qu’envoyer des évènements aux clients connectés. Dernier inconvénient face aux WebSocket, les SSEs ne peuvent faire transiter que du texte, pas de binaire, ce qui laisse quand même la possibilité d’utiliser du JSON.

nous devons utiliser zone lorsque nous travaillons avec des événements envoyés par le serveur
* car il s'agit d'opérations asynchrones exécutées en dehors de la portée de détection des modifications
* et nous devons informer Angular des changements liés aux événements SSE

## Avantages

* Reconnexion automatique 

## Désavantages

* Moins efficace qu'une WebSocket car données en text et pas en binaire
* L'API native ne gère pas les headers 

## Surcouche 

* https://github.com/EventSource/eventsource
* https://github.com/Yaffle/EventSource (semble abandonné)
* https://github.com/Azure/fetch-event-source

## Format de l'event

On envoi le header `Content-Type: text/event-stream`

et le format est :

```bash
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

data: Ici un message système quelconque qui sera utilisé
data: pour accomplir une tâche.

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}
```

On peut mettre plusieurs message dans un event, avec le caractère saut de ligne `\n`.

On peut ajouter un id a l'event avec la propriété `id` :
```bash
id: 1
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}
```

La définition d'un ID permet au navigateur de suivre le dernier événement déclenché. Si la connexion au serveur est interrompue, un en-tête HTTP spécial (Last-Event-ID) est défini avec la nouvelle requête. Cela permet au navigateur de déterminer l'événement approprié à déclencher. 
L'événement message contient une propriété e.lastEventId.

## Contrôler le délai d'expiration de la reconnexion

Le navigateur tente de se reconnecter à la source environ trois secondes après la fermeture de chaque connexion. Vous pouvez modifier ce délai en incluant une ligne commençant par retry:, suivie du nombre de millisecondes d'attente avant d'essayer de se reconnecter.

L'exemple suivant tente de se reconnecter après 10 secondes:

```bash
retry: 10000\n
data: hello world\n\n
```

## Implementation basique avec Express 

```javascript 
app.get('/events', (req, res) => {
    // Send the SSE header.
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*' // Cors
    });

    // Sends an event to the client where the data is the current date,
    // then schedules the event to happen again after 5 seconds.
    const interval = setInterval(() => {
      console.log('sending message');
      res.write('data: ' + new Date().toLocaleTimeString() + '\n\n');
    }, 5000);

    req.on('close', () => {
      console.log('client closed connection');
      clearInterval(interval); // Stop sending messages after user closes connection
    });
});
```

### Implementation basique coté client

```javascript
const eventSource = new EventSource('http://localhost:3000');

eventSource.onmessage = (event) => {
  console.log(event.data);
};
```

### Unit test 

Mocker rapidement la classe EventSource :

```typescript
/**
* Simple mock of the EventSource for testing
*/
export class EventSourceMock {
   private listeners = [];

   addEventListener(eventName: string, cb: Function) {
       this.listeners.push(cb);
   };

   onerror(error: any) {}

   // Helper method for emitting errors
   emitError(data: any) {
       this.onerror(data);
   };

   // Helper method for emitting events
   emit(data: any) {
       this.listeners.forEach(cb => cb(data))
   };
}
```
